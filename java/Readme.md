## Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

### Java 中垃圾回收机制中如何判断对象需要回收
**1. 引用计数法**  
引用计数法是通过在对象头中分配一个空间来保存该对象被引用的次数，如果该对象被其他对象引用，则它的引用计数加1，如果删除对该对象的引用，
则它的引用减1，当该对象的引用计数为0时，那么该对象就会被回收。
```
String m = new String("jack");
```
先创建一个字符串，这时候"jack"有一个引用，就是m
```
m = null;
```
然后m设置为null，这时候"jack"的引用计数就等于0，在引用计数算法中，意味着这块内容即将被回收
引用计数算法是将垃圾回收分摊到整个应用程序当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。
但是引用计数算法不属于JVM的"Stop-The-World"，所以Java放弃了使用引用计数算法
如果定义两个对象并相互引用，最后置空各自的声明引用，虽然两个对象已不能再访问，但由于它们相互引用，导致他们的引用计数不为0，那么GC收集器永远不会回收它们

**2.可达性分析算法**
可达性分析算法的基本思路是，通过一些被称为引用链(GC Roots)的对象作为起点，从这些节点开始向下搜索，当一个对象到GC Roots没有任何引用链相连时(即GC Roots节点到该节点不可达时)，则证明该对象不可用。
被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程仍然没有逃脱成为可回收对象的可能性，则会被判定为可回收对象。

在Java语言中，可作为GC Roots的对象包含:
* 1.虚拟机栈中引用的对象。在程序中创建一个对象，对象会在堆中开辟一块空间，同时会将地址作为引用存入到栈中，如果对象生命周期结束了，那么引用就会从栈中出栈。因此虚拟机栈中有引用，说明该对象不可回收。
* 2.方法区中静态属性引用的对象。由于虚拟机栈是线程私有的，因此全局的静态对象static的引用会存入共有的方法区中，将方法区中静态引用作为GC Roots是必须的
* 3.方法区中常量引用的对象。由于该引用创建之后不会修改static final，所以方法区常量池的引用对象也应该作为GC Roots
* 4.本地方法中(Native方法)引用的对象。在使用JNI技术时，调用C与C++的代码会使用Native方法，JVM内存中会有一块本地方法栈保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots

**3.finallze()方法最终判定对象是否存活**
在可达性分析算法中不可达的对象要经历标记过程判定是否回收
1.第一次标记进行一次筛选
当对象没有覆盖finallze方法，或者finallze方法已经被虚拟机调用过，虚拟机会将这两种情况视为没有必要执行。对象会被回收

2.第二次标记
如果对象被判定为需要执行finallze方法时，对象会被放在一个名为F-Queue队列中，稍后会由一个Finallze线程去执行
如果对象在Finallze中重新与GC Roots上的任何一个对象建立关联，那么会将该对象移除即将回收的集合，如果未建立关联，则被回收

### 常见的GC回收算法

**1.标记清除算法**
标记清除算法分为两个阶段: 标记阶段和清除阶段，标记阶段是标记出所有需要被回收的对象，清除阶段就是回收标记的对象占用的空间
标记清除算法比较容易实现，但容易产生内存碎片，碎片太多会导致下一次大对象分配空间无法找到足够的空间从而触发新的垃圾回收
**2.复制算法**
复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存使用完将存活的对象复制到另一块上，再将已使用的内存空间一次清理掉。
**3.标记整理算法**
标记阶段标记完成后，将存活的对象都向一端移动，然后清理掉边界以外的内存。
**4.分代收集算法**
分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据存活的生命周期将内存划分为若干个不同区域。
一般情况下将堆区划分为老年代和新生代，老年代的特点是每次垃圾回收时只有少量的对象被回收，而新生代的特点是每次垃圾回收有大量的对象被回收。
目前大部分垃圾收集器对新生代采用复制算法，因为新生代大部分对象要回收，需要复制的次数较少，一般会将新生代划分为一块较大的Eden和两块较小的Survivor,
每次使用Eden和一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。
由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记整理算法

在堆区之外还有一个代就是永久代，对永久代的回收主要回收两部分内容：废弃常量和无用的类。

## hashmap 和 hashtable 的区别是什么？

**1.继承父类不同**
HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口
**2.对外提供接口不同**
Hashtable比HashMap多提供了elments() 和contains() 两个方法。
**3.对Null key 和Null value的支持不同**
Hashtable既不支持Null key也不支持Null value。
HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。
**4.线程安全性不同**
Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步
HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。
**5.遍历方式的内部实现上不同**
Hashtable、HashMap都使用了 Iterator。Hashtable还使用了Enumeration的方式 。
**6.初始容量大小和每次扩充容量大小的不同**
Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。
**7.计算hash值的方法不同**
Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。
HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。
**8.解决hash冲突方式不同**
在HashMap中如果冲突数量小于8，则是以链表方式解决冲突。而当冲突大于等于8时，就会将冲突的Entry转换为红黑树进行存储。而又当数量小于6时，则又转化为链表存储。
在HashTable中，都是以链表方式存储。