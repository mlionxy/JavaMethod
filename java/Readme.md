## Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

### 1.Java 中垃圾回收机制中如何判断对象需要回收

**1. 引用计数法**  

引用计数法是通过在对象头中分配一个空间来保存该对象被引用的次数，如果该对象被其他对象引用，则它的引用计数加1，如果删除对该对象的引用，
则它的引用减1，当该对象的引用计数为0时，那么该对象就会被回收。
```
String m = new String("jack");
```
先创建一个字符串，这时候"jack"有一个引用，就是m
```
m = null;
```
然后m设置为null，这时候"jack"的引用计数就等于0，在引用计数算法中，意味着这块内容即将被回收
引用计数算法是将垃圾回收分摊到整个应用程序当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。
但是引用计数算法不属于JVM的"Stop-The-World"，所以Java放弃了使用引用计数算法
如果定义两个对象并相互引用，最后置空各自的声明引用，虽然两个对象已不能再访问，但由于它们相互引用，导致他们的引用计数不为0，那么GC收集器永远不会回收它们

**2.可达性分析算法**

可达性分析算法的基本思路是，通过一些被称为引用链(GC Roots)的对象作为起点，从这些节点开始向下搜索，当一个对象到GC Roots没有任何引用链相连时(即GC Roots节点到该节点不可达时)，则证明该对象不可用。
被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程仍然没有逃脱成为可回收对象的可能性，则会被判定为可回收对象。

在Java语言中，可作为GC Roots的对象包含:
* 1.虚拟机栈中引用的对象。在程序中创建一个对象，对象会在堆中开辟一块空间，同时会将地址作为引用存入到栈中，如果对象生命周期结束了，那么引用就会从栈中出栈。因此虚拟机栈中有引用，说明该对象不可回收。
* 2.方法区中静态属性引用的对象。由于虚拟机栈是线程私有的，因此全局的静态对象static的引用会存入共有的方法区中，将方法区中静态引用作为GC Roots是必须的
* 3.方法区中常量引用的对象。由于该引用创建之后不会修改static final，所以方法区常量池的引用对象也应该作为GC Roots
* 4.本地方法中(Native方法)引用的对象。在使用JNI技术时，调用C与C++的代码会使用Native方法，JVM内存中会有一块本地方法栈保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots

**3.finallze()方法最终判定对象是否存活**

在可达性分析算法中不可达的对象要经历标记过程判定是否回收
1.第一次标记进行一次筛选
当对象没有覆盖finallze方法，或者finallze方法已经被虚拟机调用过，虚拟机会将这两种情况视为没有必要执行。对象会被回收

2.第二次标记
如果对象被判定为需要执行finallze方法时，对象会被放在一个名为F-Queue队列中，稍后会由一个Finallze线程去执行
如果对象在Finallze中重新与GC Roots上的任何一个对象建立关联，那么会将该对象移除即将回收的集合，如果未建立关联，则被回收

### 2.常见的GC回收算法

**1.标记清除算法**

标记清除算法分为两个阶段: 标记阶段和清除阶段，标记阶段是标记出所有需要被回收的对象，清除阶段就是回收标记的对象占用的空间
标记清除算法比较容易实现，但容易产生内存碎片，碎片太多会导致下一次大对象分配空间无法找到足够的空间从而触发新的垃圾回收

**2.复制算法**

复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存使用完将存活的对象复制到另一块上，再将已使用的内存空间一次清理掉。

**3.标记整理算法**

标记阶段标记完成后，将存活的对象都向一端移动，然后清理掉边界以外的内存。

**4.分代收集算法**

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据存活的生命周期将内存划分为若干个不同区域。
一般情况下将堆区划分为老年代和新生代，老年代的特点是每次垃圾回收时只有少量的对象被回收，而新生代的特点是每次垃圾回收有大量的对象被回收。
目前大部分垃圾收集器对新生代采用复制算法，因为新生代大部分对象要回收，需要复制的次数较少，一般会将新生代划分为一块较大的Eden和两块较小的Survivor,
每次使用Eden和一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。
由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记整理算法

在堆区之外还有一个代就是永久代，对永久代的回收主要回收两部分内容：废弃常量和无用的类。

## hashmap 和 hashtable 的区别是什么？

**1.继承父类不同**

HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口

**2.对外提供接口不同**

Hashtable比HashMap多提供了elments() 和contains() 两个方法。

**3.对Null key 和Null value的支持不同**

Hashtable既不支持Null key也不支持Null value。
HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

**4.线程安全性不同**

Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步
HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。

**5.遍历方式的内部实现上不同**

Hashtable、HashMap都使用了 Iterator。Hashtable还使用了Enumeration的方式 。

**6.初始容量大小和每次扩充容量大小的不同**

Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。

**7.计算hash值的方法不同**

Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。
HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。

**8.解决hash冲突方式不同**

在HashMap中如果冲突数量小于8，则是以链表方式解决冲突。而当冲突大于等于8时，就会将冲突的Entry转换为红黑树进行存储。而又当数量小于6时，则又转化为链表存储。
在HashTable中，都是以链表方式存储。

## HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？

### HashMap实现原理

**1.存储结构**

HashMap采用Entry数组存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有next指针，可以链接下一个Entry实体，以此来解决hash冲突的问题。
数组存储区间是连续的，占用内存严重，故空间复杂度很大。但数组的二分查找时间复杂度小，为O(1),数组的特点是，寻址容易，插入删除困难。
链表存储区间离散，占用内存比较宽松，故空间复杂度小，但时间复杂度很大，达O(N)。链表的特点是，寻址困难，插入和删除容易。
HashMap数据结构是由数组+链表组成，一个长度16的数组中，每一个元素存储的是链表的头节点，通过计算hash(key.hashCode())%len获得，也就是元素key的hash值对数组长度取余得到。比如12，28，108，140它们计算结果都是12所以它们存储在数组下标为12的位置。
Entry里面主要属性key，value，hash，next，第一个键值对A进来，通过计算其key的hash得到的index=0，Entry[0] = A。键值对B，通过计算其index等于0，HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C

**2.JDK 1.8的 改变**

在Jdk1.8中HashMap数据结构存储方式为数组+链表+红黑树的存储方式，当链表的长度超过8时，将链表转换为红黑树。

### ConcurrentHashMap实现原理，如何保证线程安全

**1.存储结构**

ConcurrentHashMap和HashMap实现上类似，最主要的差别是ConcurrentHashMap采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），
多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。Segment继承自ReentrantLock。默认的并发级别为16，也就是说默认创建16个Segment。

**2.size操作**

每个Segment维护了一个count变量来统计该Segment中的键值对个数。在执行size操作时，需要遍历所有Segment然后把count累计起来。ConcurrentHashMap在执行size操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。
尝试次数使用RETRIES_BEFORE_LOCK定义，该值为2，retries初始值为-1，因此尝试次数为3。如果尝试的次数超过3次，就需要对每个Segment加锁。

**3.JDK 1.8 的改动**

JDK1.7使用分段锁机制来实现并发更新操作，核心类为Segment，它继承自重入锁ReentrantLock，并发度与Segment数量相等。JDK1.8使用了CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁synchronized。
JDK1.8的实现也在链表过长时会转换为红黑树。

## 简述 Java 的反射机制及其应用场景

### 反射的机制

Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。
Class和java.lang.reflect一起对反射提供了支持，java.lang.reflect类库主要包含了以下三个类：
* Field：可以使用get()和set()方法读取和修改Field对象关联的字段。
* Method：可以使用invoke()方法调用与Method对象关联的方法。
* Constructor：可以用Constructor的newInstance()创建新的对象。

### 反射的应用

* 反射让开发人员可以通过外部类的全路径名来创建对象，并使用这些类，实现一些扩展的功能。
* 反射让开发人员可以枚举出类的全部成员，包括构造函数，属性，方法。以帮助开发者写出正确的代码。
* 测试时可以利用反射API访问类的私有成员。以保证测试代码覆盖率。