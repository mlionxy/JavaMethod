## Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

### 1.Java 中垃圾回收机制中如何判断对象需要回收

**1. 引用计数法**  

引用计数法是通过在对象头中分配一个空间来保存该对象被引用的次数，如果该对象被其他对象引用，则它的引用计数加1，如果删除对该对象的引用，
则它的引用减1，当该对象的引用计数为0时，那么该对象就会被回收。
```
String m = new String("jack");
```
先创建一个字符串，这时候"jack"有一个引用，就是m
```
m = null;
```
然后m设置为null，这时候"jack"的引用计数就等于0，在引用计数算法中，意味着这块内容即将被回收
引用计数算法是将垃圾回收分摊到整个应用程序当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。
但是引用计数算法不属于JVM的"Stop-The-World"，所以Java放弃了使用引用计数算法
如果定义两个对象并相互引用，最后置空各自的声明引用，虽然两个对象已不能再访问，但由于它们相互引用，导致他们的引用计数不为0，那么GC收集器永远不会回收它们

**2.可达性分析算法**

可达性分析算法的基本思路是，通过一些被称为引用链(GC Roots)的对象作为起点，从这些节点开始向下搜索，当一个对象到GC Roots没有任何引用链相连时(即GC Roots节点到该节点不可达时)，则证明该对象不可用。
被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程仍然没有逃脱成为可回收对象的可能性，则会被判定为可回收对象。

在Java语言中，可作为GC Roots的对象包含:
* 1.虚拟机栈中引用的对象。在程序中创建一个对象，对象会在堆中开辟一块空间，同时会将地址作为引用存入到栈中，如果对象生命周期结束了，那么引用就会从栈中出栈。因此虚拟机栈中有引用，说明该对象不可回收。
* 2.方法区中静态属性引用的对象。由于虚拟机栈是线程私有的，因此全局的静态对象static的引用会存入共有的方法区中，将方法区中静态引用作为GC Roots是必须的
* 3.方法区中常量引用的对象。由于该引用创建之后不会修改static final，所以方法区常量池的引用对象也应该作为GC Roots
* 4.本地方法中(Native方法)引用的对象。在使用JNI技术时，调用C与C++的代码会使用Native方法，JVM内存中会有一块本地方法栈保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots

**3.finallze()方法最终判定对象是否存活**

在可达性分析算法中不可达的对象要经历标记过程判定是否回收
1.第一次标记进行一次筛选
当对象没有覆盖finallze方法，或者finallze方法已经被虚拟机调用过，虚拟机会将这两种情况视为没有必要执行。对象会被回收

2.第二次标记
如果对象被判定为需要执行finallze方法时，对象会被放在一个名为F-Queue队列中，稍后会由一个Finallze线程去执行
如果对象在Finallze中重新与GC Roots上的任何一个对象建立关联，那么会将该对象移除即将回收的集合，如果未建立关联，则被回收

### 2.常见的GC回收算法

**1.标记清除算法**

标记清除算法分为两个阶段: 标记阶段和清除阶段，标记阶段是标记出所有需要被回收的对象，清除阶段就是回收标记的对象占用的空间
标记清除算法比较容易实现，但容易产生内存碎片，碎片太多会导致下一次大对象分配空间无法找到足够的空间从而触发新的垃圾回收

**2.复制算法**

复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存使用完将存活的对象复制到另一块上，再将已使用的内存空间一次清理掉。

**3.标记整理算法**

标记阶段标记完成后，将存活的对象都向一端移动，然后清理掉边界以外的内存。

**4.分代收集算法**

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据存活的生命周期将内存划分为若干个不同区域。
一般情况下将堆区划分为老年代和新生代，老年代的特点是每次垃圾回收时只有少量的对象被回收，而新生代的特点是每次垃圾回收有大量的对象被回收。
目前大部分垃圾收集器对新生代采用复制算法，因为新生代大部分对象要回收，需要复制的次数较少，一般会将新生代划分为一块较大的Eden和两块较小的Survivor,
每次使用Eden和一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。
由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记整理算法

在堆区之外还有一个代就是永久代，对永久代的回收主要回收两部分内容：废弃常量和无用的类。

## hashmap 和 hashtable 的区别是什么？

**1.继承父类不同**

HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口

**2.对外提供接口不同**

Hashtable比HashMap多提供了elments() 和contains() 两个方法。

**3.对Null key 和Null value的支持不同**

Hashtable既不支持Null key也不支持Null value。
HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

**4.线程安全性不同**

Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步
HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。

**5.遍历方式的内部实现上不同**

Hashtable、HashMap都使用了 Iterator。Hashtable还使用了Enumeration的方式 。

**6.初始容量大小和每次扩充容量大小的不同**

Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。

**7.计算hash值的方法不同**

Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。
HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。

**8.解决hash冲突方式不同**

在HashMap中如果冲突数量小于8，则是以链表方式解决冲突。而当冲突大于等于8时，就会将冲突的Entry转换为红黑树进行存储。而又当数量小于6时，则又转化为链表存储。
在HashTable中，都是以链表方式存储。

## HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？

### HashMap实现原理

**1.存储结构**

HashMap采用Entry数组存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有next指针，可以链接下一个Entry实体，以此来解决hash冲突的问题。
数组存储区间是连续的，占用内存严重，故空间复杂度很大。但数组的二分查找时间复杂度小，为O(1),数组的特点是，寻址容易，插入删除困难。
链表存储区间离散，占用内存比较宽松，故空间复杂度小，但时间复杂度很大，达O(N)。链表的特点是，寻址困难，插入和删除容易。
HashMap数据结构是由数组+链表组成，一个长度16的数组中，每一个元素存储的是链表的头节点，通过计算hash(key.hashCode())%len获得，也就是元素key的hash值对数组长度取余得到。比如12，28，108，140它们计算结果都是12所以它们存储在数组下标为12的位置。
Entry里面主要属性key，value，hash，next，第一个键值对A进来，通过计算其key的hash得到的index=0，Entry[0] = A。键值对B，通过计算其index等于0，HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C

**2.JDK 1.8的 改变**

在Jdk1.8中HashMap数据结构存储方式为数组+链表+红黑树的存储方式，当链表的长度超过8时，将链表转换为红黑树。

### ConcurrentHashMap实现原理，如何保证线程安全

**1.存储结构**

ConcurrentHashMap和HashMap实现上类似，最主要的差别是ConcurrentHashMap采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），
多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。Segment继承自ReentrantLock。默认的并发级别为16，也就是说默认创建16个Segment。

**2.size操作**

每个Segment维护了一个count变量来统计该Segment中的键值对个数。在执行size操作时，需要遍历所有Segment然后把count累计起来。ConcurrentHashMap在执行size操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。
尝试次数使用RETRIES_BEFORE_LOCK定义，该值为2，retries初始值为-1，因此尝试次数为3。如果尝试的次数超过3次，就需要对每个Segment加锁。

**3.JDK 1.8 的改动**

JDK1.7使用分段锁机制来实现并发更新操作，核心类为Segment，它继承自重入锁ReentrantLock，并发度与Segment数量相等。JDK1.8使用了CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁synchronized。
JDK1.8的实现也在链表过长时会转换为红黑树。

## 简述 Java 的反射机制及其应用场景

### 反射的机制
Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。
Class和java.lang.reflect一起对反射提供了支持，java.lang.reflect类库主要包含了以下三个类：
* Field：可以使用get()和set()方法读取和修改Field对象关联的字段。
* Method：可以使用invoke()方法调用与Method对象关联的方法。
* Constructor：可以用Constructor的newInstance()创建新的对象。

### 反射的应用

* 反射让开发人员可以通过外部类的全路径名来创建对象，并使用这些类，实现一些扩展的功能。
* 反射让开发人员可以枚举出类的全部成员，包括构造函数，属性，方法。以帮助开发者写出正确的代码。
* 测试时可以利用反射API访问类的私有成员。以保证测试代码覆盖率。

## Java 类的加载流程是怎样的？什么是双亲委派机制？

### Java 类的加载流程

JVM把class文件加载在内存中，并对数据进行校验，准备，解析，初始化，最终形成JVM可以直接使用的Java类型的过程。
加载-验证-准备-解析-初始化-使用-卸载

**1.加载**

把class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量，静态代码块，常量池等），在堆中生成一个Class类对象代表这个类，作为方法区类数据的访问入口。

**2.链接**

将Java类的二进制代码合并到JVM的运行状态之中。

* 验证

确保加载的类信息符合JVM规范，没有安全方面问题。

* 准备

正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。

* 解析

虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。

**3.初始化**

初始化阶段是执行类构造器方法的过程。类构造器方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。
当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。虚拟机会保证一个类的方法在多线程环境中被正确加锁和同步

### 双亲委派机制

某个特定的类加载器接收到类加载的请求时，会将加载任务委托给自己的父类，直到最高级父类引导类加载器，如果父类能够加载就加载，不能加载则返回到子类进行加载。如果都不能加载则报错。ClassNotFoundException。
双亲委派机制是为了保证Java核心库的类型安全。这种机制保证不会出现用户自己能定义java.lang.Object类等的情况。例如，用户定义了java.lang.String，那么加载这个类时最高级父类会首先加载，发现核心类中也有这个类，那么就加载了核心类库，而自定义的永远都不会加载。

## HashMap 实现原理，为什么使用红黑树？

**HHashMap 实现原理**

HashMap采用Entry数组存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有next指针，可以链接下一个Entry实体，以此来解决hash冲突的问题。
数组存储区间是连续的，占用内存严重，故空间复杂度很大。但数组的二分查找时间复杂度小，为O(1),数组的特点是，寻址容易，插入删除困难。
链表存储区间离散，占用内存比较宽松，故空间复杂度小，但时间复杂度很大，达O(N)。链表的特点是，寻址困难，插入和删除容易。
HashMap数据结构是由数组+链表组成，一个长度16的数组中，每一个元素存储的是链表的头节点，通过计算hash(key.hashCode())%len获得，也就是元素key的hash值对数组长度取余得到。比如12，28，108，140它们计算结果都是12所以它们存储在数组下标为12的位置。
Entry里面主要属性key，value，hash，next，第一个键值对A进来，通过计算其key的hash得到的index=0，Entry[0] = A。键值对B，通过计算其index等于0，HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C

**为什么使用红黑树**

在JDK1.8之前HashMap使用数组+链表实现。使用链表处理冲突，同一hash值的数据都存在一个链表里。当一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。
在JDK1.8之后HashMap使用数组+链表+红黑树实现。当链表的长度超过阈值8时，将链表转换为红黑树，以加快检索速度。
受随机分布的hashCode影响，链表中的节点遵循泊松分布，根据统计，链表中节点数是8的概率较低，此时链表的性能较差。所以在这种情况下，会把链表转变为红黑树。因为链表转换为红黑树是需要消耗性能的，为了挽回性能，权衡之下，才使用红黑树，提高性能。在大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容

## Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？

### Synchronized 底层原理

synchronized修饰的方法在字节码中添加了一个ACC_SYNCHRONIZED的flags,
同步代码块则是在同步代码块前插入monitorenter，在同步代码块结束后插入monitorexit。
这两者的处理是分别是这样的：当线程执行到某个方法时，JVM会去检查该方法的ACC_SYNCHRONIZED访问标志是否被设置，
如果设置了那线程会去获取这个对象所对应的monitor对象（每一个对象都有且仅有一个与之对应的monitor对象）,获取成功后才执行方法体，
方法执行完再释放monitor对象，在这一期间，任何其他线程都无法获得这个monitor对象。
而线程执行同步代码块时遇到的monitorenter和monitorexit指令依赖monitor对象完成。
这两者实现的方式本质上无区别，只是方法的同步是一种隐式的方式，不通过字节码实现。
同步和monitor有关，而monitor则和对象头有关。

**synchronized影响性能的原因**

* 1、加锁解锁操作需要额外操作；
* 2、互斥同步对性能最大的影响是阻塞的实现，因为阻塞涉及到的挂起线程和恢复线程的操作都需要转入内核态中完成（用户态与内核态的切换的性能代价是比较大的）

### Synchronized 与 Lock 区别

* synchronized是Java语法的一个关键字，加锁的过程是在JVM底层进行。Lock是一个类，是JDK应用层面的，在JUC包里有丰富的API。
* Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
* Lock锁有丰富的API能知道线程是否获取锁成功，而synchronized不能。
* synchronized能修饰方法和代码块，Lock锁只能锁住代码块。
* Lock锁有丰富的API，可根据不同的场景，在使用上更加灵活。
* synchronized是非公平锁，而Lock锁既有非公平锁也有公平锁，可以由开发者通过参数控制。
* synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

## HashMap 1.7 / 1.8 的实现区别

* 1.new HashMap():底层没有创建一个长度为16的数组
* 2.jdk 8底层的数组是：Node[],而非Entry[]
* 3.首次调用put()方法时，底层创建长度为16的数组
* 4.jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。
	形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
	当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。
	红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。
